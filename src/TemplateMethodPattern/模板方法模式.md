#### 模板方法模式
    在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。
    模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
    
实例代码：
> ```abstract class AbstractClass{
>   final void methodArch{
>       methodone();
>       methodtwo();
>       hook();    
>   }  
>   abstract void methodone();
>   abstract void methodtwo();
>   void hook(){}   //钩子方法
> }
> class one extends AbstractClass{
>         void methodone(){
>             //实现
>          }
>         void methodtwo(){
>             //实现
>          }
>           void hook(){
>               //钩子方法，子类可以实现可以不实现
>            }
> }
` ``

1. 首先父类构建了算法的骨架，并且设置final，防止子类实现
2. 子类可以实现算法中可变的部分，实现部分修改算法，但骨架未被改变
3. 钩子方法
> 1. 让子类实现算法中可选的部分，或子类对钩子的方法不关心，就可以不实现
> 2. 另一个作用是，让子类能够有机会对模板方法中某些即将发生的步骤做出反应
4. 怎么才知道应该是使用抽象方法，还是钩子方法？
> 当子类必须提供算法的步骤实现时，就使用抽象方法；如果算法的部分在子类中是可选的，则在父类设置一个钩子方法，让必要的子类实现它


#### 模板方法模式和其他模式的对比

策略模式
> 封装可互换的行为，然后使用委托来决定哪一个行为；封装的是算法的全部，然后通过组合的方式进行替换，而
> 模板方法模式是父类实现算法的骨架，然后子类重新实现部分算法
